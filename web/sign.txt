<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Mini eSign ‚Äì Sign Document</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Signature Fonts -->
  <link
    href="https://fonts.googleapis.com/css2?family=Allura&family=Dancing+Script:wght@700&family=Great+Vibes&family=Pacifico&family=Satisfy&display=swap"
    rel="stylesheet">

  <style>
    :root {
      color-scheme: dark;
    }

    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex;
      height: 100vh;
    }

    aside {
      width: 366px;
      padding: 12px;
      background: #1b1b1b;
      overflow-y: auto;
      border-right: 1px solid #2a2a2a;
    }

    main {
      flex: 1;
      display: flex;
      align-items: flex-start;
      overflow-y: auto;
      padding: 12px;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .panel {
      background: #151515;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
    }

    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }

    iframe.docFrame {
      width: 800px;
      height: 1100px;
      border: 1px solid #444;
      background: #fff;
    }

    #sigPad {
      width: 100%;
      height: 160px;
      border: 2px solid #0af;
      background: transparent;
      border-radius: 6px;
      touch-action: none;
    }

    button {
      margin: 4px 0;
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: #2a2a2a;
      color: #eee;
    }

    #sigModal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #sigModalInner {
      background: #fff;
      border-radius: 8px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 90%;
      max-width: 800px;
      height: 50vh;
      /* half of screen */
    }

    #bigSigCanvas {
      border: 2px solid #0af;
      border-radius: 6px;
      background: #fff;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    button.primary {
      background: #0af;
      color: #fff;
    }

    input[type=text],
    input[type=file] {
      width: 100%;
      padding: 8px;
      margin: 6px 0;
      border-radius: 6px;
      border: 1px solid #444;
      background: #fff;
      color: #000;
    }

    #fontPreviewArea>.preview {
      margin: 6px 0;
      padding: 8px 10px;
      background: #222;
      border: 1px solid #333;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      color: #fff;
      user-select: none;
      transition: background .15s ease, transform .06s ease;
    }

    #fontPreviewArea>.preview:hover {
      background: #2a2a2a;
    }

    #fontPreviewArea>.preview:active {
      transform: scale(0.99);
    }

    #msg {
      font-size: 12px;
      margin-top: 6px;
      min-height: 16px;
      color: #b9e3ff;
    }

    .signature-line {
      min-height: 60px;
      border-bottom: 2px dashed #888;
      position: relative;
    }
  </style>
</head>

<body>
  <aside>
    <div class="panel">
      <h3>Envelope</h3>
      <div id="envelopeInfo">Loading‚Ä¶</div>
    </div>

    <div class="panel">
      <h3>Signature Pad</h3>
      <canvas id="sigPad"></canvas><br>
      <button id="sigClear">Clear</button>
      <button id="sigDrag" class="primary" draggable="true">Drag Pad Sign</button>
    </div>

    <div id="sigModal">
      <div id="sigModalInner">
        <canvas id="bigSigCanvas"></canvas>
        <div>
          <button id="bigSigClear">Clear</button>
          <button id="bigSigDone" class="primary">Done</button>
          <button id="bigSigClose">Cancel</button>
        </div>
      </div>
    </div>


    <div class="panel">
      <h3>Text Signature</h3>
      <input type="text" id="nameInput" placeholder="Type your name">
      <div id="fontPreviewArea" style="margin-top:8px;"></div>
      <button id="selectTextSign" class="primary" style="background:#444;">Select Sign</button>
      <button id="nameDrag" class="primary" draggable="true">Drag Sign</button>
    </div>

    <div class="panel">
      <h3>Image Signature</h3>
      <input type="file" id="sigImgInput" accept="image/*">
      <button id="imgDrag" class="primary" draggable="true">Drag Image Sign</button>
    </div>

    <div class="panel">
      <h3>Actions</h3>
      <button id="applyAllBtn" class="primary" style="background:#28a745;">Apply to All Docs</button>
      <button id="cancelBtn">Cancel</button>
      <button id="completeBtn" class="primary">Complete</button>
      <div id="msg"></div>
    </div>
  </aside>

  <main>
    <div id="stage"></div>
  </main>

  <script>
    (function () {
      const stage = document.getElementById("stage");
      const msg = document.getElementById("msg");
      const sigPad = document.getElementById("sigPad");
      const token = location.pathname.split("/").pop();
      const BASE = location.origin;

      let padSig = null, nameSig = null, imgSig = null;
      let lastSigType = null;

      function setMsg(t) { msg.textContent = t || ""; }

      // ===== Clear/Reset helpers =====
      function clearPad() {
        const c = sigPad.getContext("2d");
        c.clearRect(0, 0, sigPad.width, sigPad.height);
      }

      function resetOtherSigns(except) {
        if (except !== "pad") { clearPad(); padSig = null; }
        if (except !== "name") {
          nameSig = null;
          document.getElementById("nameInput").value = "";
          updateFontPreviews();
        }
        if (except !== "img") {
          imgSig = null;
          document.getElementById("sigImgInput").value = "";
        }
      }

      // ===== Signature Pad (HiDPI) =====
      const pctx = sigPad.getContext("2d");
      function setupPad() {
        const dpr = window.devicePixelRatio || 1;
        const rect = sigPad.getBoundingClientRect();
        sigPad.width = rect.width * dpr;
        sigPad.height = rect.height * dpr;
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.lineWidth = 4; // thicker line
        pctx.lineJoin = "round";
        pctx.lineCap = "round";
        pctx.strokeStyle = "#000";
      }

      setupPad();
      window.addEventListener("resize", setupPad);

      let drawing = false, lx = 0, ly = 0;
      sigPad.addEventListener("mousedown", e => { drawing = true; lx = e.offsetX; ly = e.offsetY; });
      sigPad.addEventListener("mousemove", e => {
        if (!drawing) return;
        pctx.beginPath();
        pctx.moveTo(lx, ly);
        pctx.lineTo(e.offsetX, e.offsetY);
        pctx.stroke();
        lx = e.offsetX; ly = e.offsetY;
      });
      window.addEventListener("mouseup", () => {
        if (!drawing) return;
        drawing = false;
        padSig = sigPad.toDataURL("image/png");
        lastSigType = "pad";
        resetOtherSigns("pad");
        setMsg("üñãÔ∏è Pad signature ready (others cleared)");
      });
      document.getElementById("sigClear").onclick = () => { clearPad(); padSig = null; setMsg("Pad cleared"); };

      // ===== Typed Signature (SignWell-like) =====
      const nameInput = document.getElementById("nameInput");
      const fontPreviewArea = document.getElementById("fontPreviewArea");
      const selectBtn = document.getElementById("selectTextSign");

      const fonts = [
        { name: "Great Vibes", css: "Great Vibes, cursive" },
        { name: "Pacifico", css: "Pacifico, cursive" },
        { name: "Dancing Script", css: "'Dancing Script', cursive" },
        { name: "Satisfy", css: "Satisfy, cursive" },
        { name: "Allura", css: "Allura, cursive" },
      ];
      let selectedFont = fonts[0].css;

      function updateFontPreviews() {
        const text = nameInput.value.trim() || "Your Name";
        fontPreviewArea.innerHTML = "";
        fonts.forEach(font => {
          const div = document.createElement("div");
          div.className = "preview";
          div.textContent = text;
          div.style.fontFamily = font.css;
          div.style.fontSize = "36px";
          div.onclick = () => {
            selectedFont = font.css;
            document.querySelectorAll(".preview").forEach(p => p.style.borderColor = "#333");
            div.style.borderColor = "#0af";
          };
          fontPreviewArea.appendChild(div);
        });
      }
      nameInput.addEventListener("input", updateFontPreviews);
      updateFontPreviews();

      function generateTextSignature(fontCSS, text) {
        const c = document.createElement("canvas");
        c.width = 500; c.height = 140;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.font = `bold 64px ${fontCSS}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 250, 70);
        return c.toDataURL("image/png");
      }

      selectBtn.onclick = () => {
        const text = nameInput.value.trim();
        if (!text) return setMsg("‚ö†Ô∏è Type your name first.");
        const sig = generateTextSignature(selectedFont, text);
        resetOtherSigns("name");
        nameSig = sig;
        lastSigType = "name";
        setMsg("‚úÖ Text signature selected (others cleared)");
      };

      document.getElementById("nameDrag").ondragstart = e => {
        if (!nameSig) { setMsg("‚ö†Ô∏è Please select a text signature first."); return e.preventDefault(); }
        e.dataTransfer.setData("sigType", "name");
        lastSigType = "name";
      };

      // ===== Image Signature =====
      document.getElementById("sigImgInput").onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        resetOtherSigns("img");
        const img = new Image();
        img.onload = () => {
          const c = document.createElement("canvas");
          c.width = img.width; c.height = img.height;
          const ctx = c.getContext("2d");
          ctx.drawImage(img, 0, 0);
          imgSig = c.toDataURL("image/png");
          lastSigType = "img";
          setMsg("üñºÔ∏è Image signature ready (others cleared)");
        };
        img.src = URL.createObjectURL(file);
      };

      // ===== Load Envelope =====
      async function loadEnvelope() {
        try {
          const resp = await fetch(`${BASE}/api/envelopes/by-token/${token}`);
          if (!resp.ok) { setMsg("Envelope not found"); return; }
          const data = await resp.json();
          document.getElementById("envelopeInfo").innerHTML = `<strong>${data.recipientName}</strong>`;
          for (const f of data.files) {
            const fileUrl = f.url.startsWith("http") ? f.url : `${BASE}${f.url}`;
            if (f.mimetype === "text/html" || fileUrl.endsWith(".html")) await renderHtmlUrl(fileUrl);
          }
        } catch { setMsg("‚ö†Ô∏è Failed to load envelope."); }
      }

      async function renderHtmlUrl(url) {
        const iframe = document.createElement("iframe");
        iframe.src = url;
        iframe.className = "docFrame";
        iframe.onload = () => setupIframeDragDrop(iframe);
        stage.appendChild(iframe);
      }

      // ===== Drag & Drop =====
      function setupIframeDragDrop(iframe) {
        const doc = iframe.contentDocument;
        doc.addEventListener("dragover", e => e.preventDefault());

        doc.addEventListener("drop", e => {
          e.preventDefault();

          const sigType = e.dataTransfer.getData("sigType");
          const sigSrc = sigType === "pad" ? padSig : sigType === "name" ? nameSig : imgSig;
          if (!sigSrc) return alert("‚ö†Ô∏è Please create a signature first.");

          // Find the correct target container
          let container = e.target.closest(".signature-line");
          if (!container) container = doc.body; // fallback if not on line

          // Ensure container can host absolute children
          if (getComputedStyle(container).position === "static") {
            container.style.position = "relative";
          }

          // Calculate coordinates correctly relative to the container
          const iframeRect = iframe.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();

          const x = e.clientX - containerRect.left + container.scrollLeft;
          const y = e.clientY - containerRect.top + container.scrollTop;

          // Boundaries check (avoid overflow)
          const safeX = Math.max(0, Math.min(x, container.clientWidth - 160));
          const safeY = Math.max(0, Math.min(y, container.clientHeight - 70));

          createSignatureElement(doc, sigSrc, safeX, safeY, container);
        });
      }

      // ===== Signature element with drag/resize/delete =====
      function createSignatureElement(doc, src, x, y, parentEl) {
        const el = doc.createElement("div");
        el.className = "placed-signature";
        Object.assign(el.style, {
          position: "absolute",
          left: x + "px",
          top: y + "px",
          width: "160px",
          height: "70px",
          backgroundImage: `url(${src})`,
          backgroundSize: "contain",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center",
          border: "2px dashed #0af",
          borderRadius: "6px",
          cursor: "move",
          userSelect: "none",
          boxSizing: "border-box",
        });

        // Close button
        const closeBtn = doc.createElement("div");
        closeBtn.textContent = "√ó";
        Object.assign(closeBtn.style, {
          position: "absolute",
          top: "-10px",
          right: "-10px",
          width: "20px",
          height: "20px",
          background: "#f33",
          color: "#fff",
          textAlign: "center",
          lineHeight: "20px",
          borderRadius: "50%",
          cursor: "pointer",
          fontWeight: "bold",
        });
        closeBtn.onclick = () => el.remove();
        el.appendChild(closeBtn);

        // Resize handle
        const handle = doc.createElement("div");
        Object.assign(handle.style, {
          position: "absolute",
          right: "-6px",
          bottom: "-6px",
          width: "12px",
          height: "12px",
          background: "#0af",
          borderRadius: "3px",
          cursor: "se-resize",
        });
        el.appendChild(handle);

        // Drag logic (bounded to parent)
        let dragging = false, dx = 0, dy = 0;
        el.addEventListener("mousedown", e => {
          if (e.target === handle || e.target === closeBtn) return;
          dragging = true;
          const r = el.getBoundingClientRect();
          dx = e.clientX - r.left;
          dy = e.clientY - r.top;
          e.preventDefault();
        });
        doc.addEventListener("mousemove", e => {
          if (!dragging) return;
          const pr = parentEl.getBoundingClientRect();
          const newL = e.clientX - pr.left - dx + parentEl.scrollLeft;
          const newT = e.clientY - pr.top - dy + parentEl.scrollTop;
          const maxL = parentEl.clientWidth - el.offsetWidth;
          const maxT = parentEl.clientHeight - el.offsetHeight;
          el.style.left = Math.max(0, Math.min(newL, maxL)) + "px";
          el.style.top = Math.max(0, Math.min(newT, maxT)) + "px";
        });
        doc.addEventListener("mouseup", () => dragging = false);

        // Resize logic (bounded to parent)
        let resizing = false, sx = 0, sy = 0, sw = 0, sh = 0;
        handle.addEventListener("mousedown", e => {
          e.stopPropagation();
          resizing = true;
          sx = e.clientX; sy = e.clientY;
          sw = el.offsetWidth; sh = el.offsetHeight;
        });
        doc.addEventListener("mousemove", e => {
          if (!resizing) return;
          const pr = parentEl.getBoundingClientRect();
          let newW = sw + (e.clientX - sx);
          let newH = sh + (e.clientY - sy);
          newW = Math.min(newW, parentEl.clientWidth - el.offsetLeft);
          newH = Math.min(newH, parentEl.clientHeight - el.offsetTop);
          el.style.width = Math.max(40, newW) + "px";
          el.style.height = Math.max(20, newH) + "px";
        });
        doc.addEventListener("mouseup", () => resizing = false);

        parentEl.appendChild(el);
      }

      // ===== Drag from sidebar =====
      document.getElementById("sigDrag").ondragstart = e => {
        if (!padSig) return e.preventDefault();
        e.dataTransfer.setData("sigType", "pad");
        lastSigType = "pad";
      };
      document.getElementById("imgDrag").ondragstart = e => {
        if (!imgSig) return e.preventDefault();
        e.dataTransfer.setData("sigType", "img");
        lastSigType = "img";
      };

      // ===== Apply to All =====
      document.getElementById("applyAllBtn").onclick = () => {
        const iframes = document.querySelectorAll(".docFrame");
        let sig = lastSigType === "pad" ? padSig : lastSigType === "name" ? nameSig : imgSig;
        if (!sig) return setMsg("No signature selected.");
        iframes.forEach(f => {
          const doc = f.contentDocument;
          doc.querySelectorAll(".signature-line").forEach(line => {
            line.style.position = "relative";
            line.innerHTML = "";
            createSignatureElement(doc, sig, 0, 0, line);
          });
        });
        setMsg("‚úÖ Signature applied to all lines.");
      };

      // ===== Cancel (clear all, call API) =====
      document.getElementById("cancelBtn").onclick = async () => {
        const iframes = document.querySelectorAll(".docFrame");
        iframes.forEach(f => {
          const doc = f.contentDocument;
          doc.querySelectorAll(".placed-signature").forEach(el => el.remove());
        });
        setMsg("‚ùå Signatures cleared, cancelling...");
        try {
          const resp = await fetch(`${BASE}/api/envelopes/${token}/cancel`, { method: "POST" });
          setMsg(resp.ok ? "‚úÖ Envelope cancelled successfully." : "‚ö†Ô∏è Cancel API failed.");
        } catch { setMsg("‚ùå Error calling cancel API."); }
      };

      // ===== Complete (strip chrome, render clean PDF, upload) =====
      document.getElementById("completeBtn").onclick = async () => {
        setMsg("üßπ Cleaning signatures...");
        const iframes = document.querySelectorAll(".docFrame");

        // Permanently remove the UI chrome (border/√ó/handle) before rendering
        iframes.forEach(f => {
          const doc = f.contentDocument;
          doc.querySelectorAll(".placed-signature").forEach(el => {
            el.style.border = "none";            // remove blue dashed box
            // remove controls
            el.querySelectorAll("div").forEach(d => d.remove());
          });
        });

        setMsg("üìÑ Generating signed PDF...");
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        let page = 0;

        for (const frame of iframes) {
          const canvas = await html2canvas(frame.contentDocument.body, { scale: 2, backgroundColor: "#ffffff" });
          const imgData = canvas.toDataURL("image/png");
          const pdfW = pdf.internal.pageSize.getWidth();
          const pdfH = pdf.internal.pageSize.getHeight();
          const ratio = Math.min(pdfW / canvas.width, pdfH / canvas.height);
          const w = canvas.width * ratio;
          const h = canvas.height * ratio;
          const x = (pdfW - w) / 2;
          const y = (pdfH - h) / 2;
          if (page > 0) pdf.addPage();
          pdf.addImage(imgData, "PNG", x, y, w, h);
          page++;
        }

        const blob = pdf.output("blob");
        const fd = new FormData();
        fd.append("file", blob, "signed-envelope.pdf");

        setMsg("üì§ Uploading signed PDF...");
        try {
          const resp = await fetch(`${BASE}/api/envelopes/${token}/complete`, { method: "POST", body: fd });
          setMsg(resp.ok ? "‚úÖ Signed PDF uploaded successfully!" : "‚ùå Upload failed.");
        } catch { setMsg("‚ùå Upload error."); }
      };

      // ===== Signature Pad Clear + Expand =====
      document.getElementById("sigClear").onclick = () => { clearPad(); padSig = null; setMsg("Pad cleared"); };

      // === Expand Pad button ===
      const expandBtn = document.createElement("button");
      expandBtn.textContent = "Expand Pad";
      expandBtn.className = "primary";
      expandBtn.style.background = "#555";
      expandBtn.style.marginTop = "6px";
      document.querySelector("#sigPad").insertAdjacentElement("afterend", expandBtn);

      // === Modal Elements ===
      const sigModal = document.getElementById("sigModal");
      const bigCanvas = document.getElementById("bigSigCanvas");
      const bigCtx = bigCanvas.getContext("2d");

      // Setup large canvas for drawing
      function setupBigCanvas() {
        const rect = bigCanvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        bigCanvas.width = rect.width * dpr;
        bigCanvas.height = rect.height * dpr;
        bigCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        bigCtx.lineWidth = 5; // thicker for large pad
        bigCtx.lineJoin = "round";
        bigCtx.lineCap = "round";
        bigCtx.strokeStyle = "#000";
      }

      setupBigCanvas();
      window.addEventListener("resize", setupBigCanvas);

      // Drawing logic for large pad
      let drawingLarge = false, x = 0, y = 0;
      bigCanvas.addEventListener("mousedown", e => {
        drawingLarge = true;
        x = e.offsetX; y = e.offsetY;
      });
      bigCanvas.addEventListener("mousemove", e => {
        if (!drawingLarge) return;
        bigCtx.beginPath();
        bigCtx.moveTo(x, y);
        bigCtx.lineTo(e.offsetX, e.offsetY);
        bigCtx.stroke();
        x = e.offsetX; y = e.offsetY;
      });
      window.addEventListener("mouseup", () => drawingLarge = false);

      // Buttons inside modal
      document.getElementById("bigSigClear").onclick = () => {
        bigCtx.clearRect(0, 0, bigCanvas.width, bigCanvas.height);
      };

      document.getElementById("bigSigClose").onclick = () => {
        sigModal.style.display = "none";
      };

      // === Done: Copy signature to small pad ===
      document.getElementById("bigSigDone").onclick = () => {
        const dataURL = bigCanvas.toDataURL("image/png");
        const ctx = sigPad.getContext("2d");

        // clear old small pad
        clearPad();

        // Load the image and draw it scaled properly
        const img = new Image();
        img.onload = () => {
          // Fit inside sigPad dimensions correctly
          ctx.drawImage(img, 0, 0, sigPad.width, sigPad.height);
          padSig = dataURL;
          lastSigType = "pad";
          resetOtherSigns("pad");
          setMsg("‚úÖ Signature imported from expanded pad (others cleared)");
        };
        img.src = dataURL;

        sigModal.style.display = "none";
      };

      // === Open modal ===
      expandBtn.onclick = () => {
        bigCtx.clearRect(0, 0, bigCanvas.width, bigCanvas.height);
        sigModal.style.display = "flex";
        setupBigCanvas();
      };

      // Init
      loadEnvelope();
    })();
  </script>

</body>

</html>
































<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Mini eSign ‚Äì Sign Document</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Signature Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Allura&family=Dancing+Script:wght@700&family=Great+Vibes&family=Pacifico&family=Satisfy&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark; }

    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex;
      height: 100vh;
    }

    aside {
      width: 280px;
      padding: 12px;
      background: #1b1b1b;
      overflow-y: auto;
      border-right: 1px solid #2a2a2a;
    }

    main {
      flex: 1;
      display: flex;
      align-items: flex-start;
      overflow-y: auto;
      padding: 12px;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .panel {
      background: #151515;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
    }

    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }

    iframe.docFrame {
      width: 800px;
      height: 1100px;
      border: 1px solid #444;
      background: #fff;
    }

    #sigPad {
      width: 100%;
      height: 160px;
      border: 2px solid #0af;
      background: transparent;
      border-radius: 6px;
      touch-action: none;
    }

    button {
      margin: 4px 0;
      padding: 8px 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: #2a2a2a;
      color: #eee;
    }

    button.primary { background: #0af; color: #fff; }

    input[type=text], input[type=file] {
      width: 100%;
      padding: 8px;
      margin: 6px 0;
      border-radius: 6px;
      border: 1px solid #444;
      background: #fff;
      color: #000;
    }

    #fontPreviewArea > .preview {
      margin: 6px 0;
      padding: 8px 10px;
      background: #222;
      border: 1px solid #333;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      color: #fff;
      user-select: none;
      transition: background .15s ease, transform .06s ease;
    }
    #fontPreviewArea > .preview:hover { background: #2a2a2a; }
    #fontPreviewArea > .preview:active { transform: scale(0.99); }

    #msg { font-size: 12px; margin-top: 6px; min-height: 16px; color: #b9e3ff; }
  </style>
</head>

<body>
  <aside>
    <div class="panel">
      <h3>Envelope</h3>
      <div id="envelopeInfo">Loading‚Ä¶</div>
    </div>

    <div class="panel">
      <h3>Signature Pad</h3>
      <canvas id="sigPad"></canvas><br>
      <button id="sigClear">Clear</button>
      <button id="sigDrag" class="primary" draggable="true">Drag Pad Sign</button>
    </div>

    <div class="panel">
      <h3>Text Signature</h3>
      <input type="text" id="nameInput" placeholder="Type your name">
      <div id="fontPreviewArea" style="margin-top:8px;"></div>
      <button id="selectTextSign" class="primary" style="background:#444;">Select Typed Sign</button>
      <button id="nameDrag" class="primary" draggable="true">Drag Selected Text Sign</button>
    </div>

    <div class="panel">
      <h3>Image Signature</h3>
      <input type="file" id="sigImgInput" accept="image/*">
      <button id="imgDrag" class="primary" draggable="true">Drag Image Sign</button>
    </div>

    <div class="panel">
      <h3>Actions</h3>
      <button id="applyAllBtn" class="primary" style="background:#28a745;">Apply to All Docs</button>
      <button id="cancelBtn">Cancel</button>
      <button id="completeBtn" class="primary">Complete</button>
      <div id="msg"></div>
    </div>
  </aside>

  <main>
    <div id="stage"></div>
  </main>

  <script>
    (function () {
      const stage = document.getElementById("stage");
      const msg = document.getElementById("msg");
      const sigPad = document.getElementById("sigPad");
      const token = location.pathname.split("/").pop();
      const BASE = location.origin;

      let padSig = null, nameSig = null, imgSig = null;
      let lastSigType = null;

      function setMsg(t) { msg.textContent = t || ""; }

      // ===== Clear/Reset helpers =====
      function clearPad() {
        const c = sigPad.getContext("2d");
        c.clearRect(0, 0, sigPad.width, sigPad.height);
      }

      function resetOtherSigns(except) {
        if (except !== "pad") { clearPad(); padSig = null; }
        if (except !== "name") {
          nameSig = null;
          document.getElementById("nameInput").value = "";
          updateFontPreviews();
        }
        if (except !== "img") {
          imgSig = null;
          document.getElementById("sigImgInput").value = "";
        }
      }

      // ===== Signature Pad (HiDPI) =====
      const pctx = sigPad.getContext("2d");
      function setupPad() {
        const dpr = window.devicePixelRatio || 1;
        const rect = sigPad.getBoundingClientRect();
        sigPad.width = rect.width * dpr;
        sigPad.height = rect.height * dpr;
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.lineWidth = 2.5;
        pctx.lineCap = "round";
        pctx.strokeStyle = "#000";
      }
      setupPad();
      window.addEventListener("resize", setupPad);

      let drawing = false, lx = 0, ly = 0;
      sigPad.addEventListener("mousedown", e => { drawing = true; lx = e.offsetX; ly = e.offsetY; });
      sigPad.addEventListener("mousemove", e => {
        if (!drawing) return;
        pctx.beginPath();
        pctx.moveTo(lx, ly);
        pctx.lineTo(e.offsetX, e.offsetY);
        pctx.stroke();
        lx = e.offsetX; ly = e.offsetY;
      });
      window.addEventListener("mouseup", () => {
        if (!drawing) return;
        drawing = false;
        padSig = sigPad.toDataURL("image/png");
        lastSigType = "pad";
        resetOtherSigns("pad");
        setMsg("üñãÔ∏è Pad signature ready (others cleared)");
      });
      document.getElementById("sigClear").onclick = () => { clearPad(); padSig = null; setMsg("Pad cleared"); };

      // ===== Typed Signature (SignWell-like) =====
      const nameInput = document.getElementById("nameInput");
      const fontPreviewArea = document.getElementById("fontPreviewArea");
      const selectBtn = document.getElementById("selectTextSign");

      const fonts = [
        { name: "Great Vibes", css: "Great Vibes, cursive" },
        { name: "Pacifico", css: "Pacifico, cursive" },
        { name: "Dancing Script", css: "'Dancing Script', cursive" },
        { name: "Satisfy", css: "Satisfy, cursive" },
        { name: "Allura", css: "Allura, cursive" },
      ];
      let selectedFont = fonts[0].css;

      function updateFontPreviews() {
        const text = nameInput.value.trim() || "Your Name";
        fontPreviewArea.innerHTML = "";
        fonts.forEach(font => {
          const div = document.createElement("div");
          div.className = "preview";
          div.textContent = text;
          div.style.fontFamily = font.css;
          div.style.fontSize = "36px";
          div.onclick = () => {
            selectedFont = font.css;
            document.querySelectorAll(".preview").forEach(p => p.style.borderColor = "#333");
            div.style.borderColor = "#0af";
          };
          fontPreviewArea.appendChild(div);
        });
      }
      nameInput.addEventListener("input", updateFontPreviews);
      updateFontPreviews();

      function generateTextSignature(fontCSS, text) {
        const c = document.createElement("canvas");
        c.width = 500; c.height = 140;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.font = `bold 64px ${fontCSS}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 250, 70);
        return c.toDataURL("image/png");
      }

      selectBtn.onclick = () => {
        const text = nameInput.value.trim();
        if (!text) return setMsg("‚ö†Ô∏è Type your name first.");
        const sig = generateTextSignature(selectedFont, text);
        resetOtherSigns("name");
        nameSig = sig;
        lastSigType = "name";
        setMsg("‚úÖ Text signature selected (others cleared)");
      };

      document.getElementById("nameDrag").ondragstart = e => {
        if (!nameSig) { setMsg("‚ö†Ô∏è Please select a text signature first."); return e.preventDefault(); }
        e.dataTransfer.setData("sigType", "name");
        lastSigType = "name";
      };

      // ===== Image Signature =====
      document.getElementById("sigImgInput").onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        resetOtherSigns("img");
        const img = new Image();
        img.onload = () => {
          const c = document.createElement("canvas");
          c.width = img.width; c.height = img.height;
          const ctx = c.getContext("2d");
          ctx.drawImage(img, 0, 0);
          imgSig = c.toDataURL("image/png");
          lastSigType = "img";
          setMsg("üñºÔ∏è Image signature ready (others cleared)");
        };
        img.src = URL.createObjectURL(file);
      };

      // ===== Load Envelope =====
      async function loadEnvelope() {
        try {
          const resp = await fetch(`${BASE}/api/envelopes/by-token/${token}`);
          if (!resp.ok) { setMsg("Envelope not found"); return; }
          const data = await resp.json();
          document.getElementById("envelopeInfo").innerHTML = `<strong>${data.recipientName}</strong>`;
          for (const f of data.files) {
            const fileUrl = f.url.startsWith("http") ? f.url : `${BASE}${f.url}`;
            if (f.mimetype === "text/html" || fileUrl.endsWith(".html")) await renderHtmlUrl(fileUrl);
          }
        } catch { setMsg("‚ö†Ô∏è Failed to load envelope."); }
      }

      async function renderHtmlUrl(url) {
        const iframe = document.createElement("iframe");
        iframe.src = url;
        iframe.className = "docFrame";
        iframe.onload = () => setupIframeDragDrop(iframe);
        stage.appendChild(iframe);
      }

      // ===== Drag & Drop =====
      function setupIframeDragDrop(iframe) {
        const doc = iframe.contentDocument;
        doc.addEventListener("dragover", e => e.preventDefault());
        doc.addEventListener("drop", e => {
          e.preventDefault();
          const sigType = e.dataTransfer.getData("sigType");
          let sigSrc = sigType === "pad" ? padSig : sigType === "name" ? nameSig : imgSig;
          if (!sigSrc) return alert("Create a signature first");
          const container = e.target.closest?.(".signature-line") || doc.body;
          const rect = container.getBoundingClientRect();
          const x = e.clientX - rect.left + container.scrollLeft;
          const y = e.clientY - rect.top + container.scrollTop;
          createSignatureElement(doc, sigSrc, x, y, container);
        });
      }

      // ===== Signature element with drag/resize/delete =====
      function createSignatureElement(doc, src, x, y, parentEl) {
        const el = doc.createElement("div");
        el.className = "placed-signature";
        Object.assign(el.style, {
          position: "absolute",
          left: x + "px",
          top: y + "px",
          width: "160px",
          height: "70px",
          backgroundImage: `url(${src})`,
          backgroundSize: "contain",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center",
          border: "2px dashed #0af",
          borderRadius: "6px",
          cursor: "move",
          userSelect: "none",
          boxSizing: "border-box",
        });

        // Close button
        const closeBtn = doc.createElement("div");
        closeBtn.textContent = "√ó";
        Object.assign(closeBtn.style, {
          position: "absolute",
          top: "-10px",
          right: "-10px",
          width: "20px",
          height: "20px",
          background: "#f33",
          color: "#fff",
          textAlign: "center",
          lineHeight: "20px",
          borderRadius: "50%",
          cursor: "pointer",
          fontWeight: "bold",
        });
        closeBtn.onclick = () => el.remove();
        el.appendChild(closeBtn);

        // Resize handle
        const handle = doc.createElement("div");
        Object.assign(handle.style, {
          position: "absolute",
          right: "-6px",
          bottom: "-6px",
          width: "12px",
          height: "12px",
          background: "#0af",
          borderRadius: "3px",
          cursor: "se-resize",
        });
        el.appendChild(handle);

        // Drag logic (bounded to parent)
        let dragging = false, dx = 0, dy = 0;
        el.addEventListener("mousedown", e => {
          if (e.target === handle || e.target === closeBtn) return;
          dragging = true;
          const r = el.getBoundingClientRect();
          dx = e.clientX - r.left;
          dy = e.clientY - r.top;
          e.preventDefault();
        });
        doc.addEventListener("mousemove", e => {
          if (!dragging) return;
          const pr = parentEl.getBoundingClientRect();
          const newL = e.clientX - pr.left - dx + parentEl.scrollLeft;
          const newT = e.clientY - pr.top - dy + parentEl.scrollTop;
          const maxL = parentEl.clientWidth - el.offsetWidth;
          const maxT = parentEl.clientHeight - el.offsetHeight;
          el.style.left = Math.max(0, Math.min(newL, maxL)) + "px";
          el.style.top  = Math.max(0, Math.min(newT, maxT)) + "px";
        });
        doc.addEventListener("mouseup", () => dragging = false);

        // Resize logic (bounded to parent)
        let resizing = false, sx = 0, sy = 0, sw = 0, sh = 0;
        handle.addEventListener("mousedown", e => {
          e.stopPropagation();
          resizing = true;
          sx = e.clientX; sy = e.clientY;
          sw = el.offsetWidth; sh = el.offsetHeight;
        });
        doc.addEventListener("mousemove", e => {
          if (!resizing) return;
          const pr = parentEl.getBoundingClientRect();
          let newW = sw + (e.clientX - sx);
          let newH = sh + (e.clientY - sy);
          newW = Math.min(newW, parentEl.clientWidth - el.offsetLeft);
          newH = Math.min(newH, parentEl.clientHeight - el.offsetTop);
          el.style.width  = Math.max(40, newW) + "px";
          el.style.height = Math.max(20, newH) + "px";
        });
        doc.addEventListener("mouseup", () => resizing = false);

        parentEl.appendChild(el);
      }

      // ===== Drag from sidebar =====
      document.getElementById("sigDrag").ondragstart = e => {
        if (!padSig) return e.preventDefault();
        e.dataTransfer.setData("sigType", "pad");
        lastSigType = "pad";
      };
      document.getElementById("imgDrag").ondragstart = e => {
        if (!imgSig) return e.preventDefault();
        e.dataTransfer.setData("sigType", "img");
        lastSigType = "img";
      };

      // ===== Apply to All =====
      document.getElementById("applyAllBtn").onclick = () => {
        const iframes = document.querySelectorAll(".docFrame");
        let sig = lastSigType === "pad" ? padSig : lastSigType === "name" ? nameSig : imgSig;
        if (!sig) return setMsg("No signature selected.");
        iframes.forEach(f => {
          const doc = f.contentDocument;
          doc.querySelectorAll(".signature-line").forEach(line => {
            line.style.position = "relative";
            line.innerHTML = "";
            createSignatureElement(doc, sig, 0, 0, line);
          });
        });
        setMsg("‚úÖ Signature applied to all lines.");
      };

      // ===== Cancel (clear all, call API) =====
      document.getElementById("cancelBtn").onclick = async () => {
        const iframes = document.querySelectorAll(".docFrame");
        iframes.forEach(f => {
          const doc = f.contentDocument;
          doc.querySelectorAll(".placed-signature").forEach(el => el.remove());
        });
        setMsg("‚ùå Signatures cleared, cancelling...");
        try {
          const resp = await fetch(`${BASE}/api/envelopes/${token}/cancel`, { method: "POST" });
          setMsg(resp.ok ? "‚úÖ Envelope cancelled successfully." : "‚ö†Ô∏è Cancel API failed.");
        } catch { setMsg("‚ùå Error calling cancel API."); }
      };

      // ===== Complete (strip chrome, render clean PDF, upload) =====
      document.getElementById("completeBtn").onclick = async () => {
        setMsg("üßπ Cleaning signatures...");
        const iframes = document.querySelectorAll(".docFrame");

        // Permanently remove the UI chrome (border/√ó/handle) before rendering
        iframes.forEach(f => {
          const doc = f.contentDocument;
          doc.querySelectorAll(".placed-signature").forEach(el => {
            el.style.border = "none";            // remove blue dashed box
            // remove controls
            el.querySelectorAll("div").forEach(d => d.remove());
          });
        });

        setMsg("üìÑ Generating signed PDF...");
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        let page = 0;

        for (const frame of iframes) {
          const canvas = await html2canvas(frame.contentDocument.body, { scale: 2, backgroundColor: "#ffffff" });
          const imgData = canvas.toDataURL("image/png");
          const pdfW = pdf.internal.pageSize.getWidth();
          const pdfH = pdf.internal.pageSize.getHeight();
          const ratio = Math.min(pdfW / canvas.width, pdfH / canvas.height);
          const w = canvas.width * ratio;
          const h = canvas.height * ratio;
          const x = (pdfW - w) / 2;
          const y = (pdfH - h) / 2;
          if (page > 0) pdf.addPage();
          pdf.addImage(imgData, "PNG", x, y, w, h);
          page++;
        }

        const blob = pdf.output("blob");
        const fd = new FormData();
        fd.append("file", blob, "signed-envelope.pdf");

        setMsg("üì§ Uploading signed PDF...");
        try {
          const resp = await fetch(`${BASE}/api/envelopes/${token}/complete`, { method: "POST", body: fd });
          setMsg(resp.ok ? "‚úÖ Signed PDF uploaded successfully!" : "‚ùå Upload failed.");
        } catch { setMsg("‚ùå Upload error."); }
      };

      // Init
      loadEnvelope();
    })();
  </script>

</body>
</html>


































<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Mini eSign ‚Äì Sign Document</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
    }

    aside {
      width: 260px;
      padding: 10px;
      background: #222;
      /* overflow-y: auto; */
    }

    main {
      flex: 1;
      display: flex;
      align-items: flex-start;
      overflow-y: auto;
      padding: 12px;
      flex-direction: column;
      align-items: center;
    }

    .panel {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 12px;
    }

    iframe.docFrame {
      width: 800px;
      height: 1100px;
      border: 1px solid #444;
      background: #fff;
      margin-bottom: 20px;
    }

    #sigPad {
      width: 100%;
      height: 120px;
      border: 2px solid #0af;
      background: transparent;
      color: white;
    }

    button {
      margin: 4px 0;
      padding: 6px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button.primary {
      background: #0af;
      color: #fff;
    }

    input[type=text],
    input[type=file] {
      width: 100%;
      padding: 6px;
      margin: 6px 0;
      border-radius: 4px;
      border: 1px solid #555;
      background: #fff;
      color: #000;
    }
  </style>
</head>

<body>
  <aside>
    <div class="panel">
      <h3>Envelope</h3>
      <div id="envelopeInfo">Loading‚Ä¶</div>
    </div>

    <div class="panel">
      <h3>Signature Pad</h3>
      <canvas id="sigPad"></canvas><br>
      <button id="sigClear">Clear</button>
      <button id="sigDrag" class="primary" draggable="true">Drag Pad Sign</button>
    </div>

    <div class="panel">
      <h3>Text Signature</h3>
      <input type="text" id="nameInput" placeholder="Type your name">
      <button id="selectTextBtn" class="primary" style="background:#555;">Select Sign</button>
      <button id="nameDrag" class="primary" draggable="true">Drag Text Sign</button>
    </div>

    <div class="panel">
      <h3>Image Signature</h3>
      <input type="file" id="sigImgInput" accept="image/*">
      <button id="imgDrag" class="primary" draggable="true">Drag Image Sign</button>
    </div>

    <div class="panel">
      <h3>Actions</h3>
      <button id="applyAllBtn" class="primary" style="background:#28a745;">Apply to All Docs</button>
      <button id="cancelBtn">Cancel</button>
      <button id="completeBtn" class="primary">Complete</button>
      <div id="msg" style="font-size:12px; margin-top:6px;"></div>
    </div>
  </aside>

  <main>
    <div id="stage"></div>
  </main>

  <script>
    (function () {
      const stage = document.getElementById("stage");
      const msg = document.getElementById("msg");
      const sigPad = document.getElementById("sigPad");
      const sigCtx = sigPad.getContext("2d");
      const token = location.pathname.split("/").pop();
      const BASE = location.origin;

      let padSig = null, nameSig = null, imgSig = null;
      let lastSigType = null;

      function clearPad() {
        sigCtx.clearRect(0, 0, sigPad.width, sigPad.height);
      }

      function resetOtherSigns(except) {
        if (except !== "pad") { clearPad(); padSig = null; }
        if (except !== "name") { nameSig = null; document.getElementById("nameInput").value = ""; }
        if (except !== "img") { imgSig = null; document.getElementById("sigImgInput").value = ""; }
      }

      // ================== Signature Pad ==================
      sigCtx.lineWidth = 2.5;
      sigCtx.lineCap = "round";
      sigCtx.strokeStyle = "#000";
      let drawing = false, lx = 0, ly = 0;
      sigPad.onmousedown = e => { drawing = true; lx = e.offsetX; ly = e.offsetY; };
      sigPad.onmousemove = e => {
        if (!drawing) return;
        sigCtx.beginPath();
        sigCtx.moveTo(lx, ly);
        sigCtx.lineTo(e.offsetX, e.offsetY);
        sigCtx.stroke();
        lx = e.offsetX; ly = e.offsetY;
      };
      window.onmouseup = () => {
        if (drawing) {
          drawing = false;
          padSig = sigPad.toDataURL("image/png");
          lastSigType = "pad";
          resetOtherSigns("pad");
          msg.textContent = "üñãÔ∏è Pad signature ready (transparent background, others cleared)";
        }
      };
      document.getElementById("sigClear").onclick = clearPad;

      // ================== Text Signature (Drag + Select) ==================
      const nameInput = document.getElementById("nameInput");
      const selectTextBtn = document.getElementById("selectTextBtn");

      function generateTextSignature() {
        const text = nameInput.value.trim();
        if (!text) {
          msg.textContent = "‚ö†Ô∏è Please type your name first.";
          return null;
        }
        const canvas = document.createElement("canvas");
        canvas.width = 300; canvas.height = 80;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, 300, 80);
        ctx.fillStyle = "#000";
        ctx.font = "bold 36px cursive";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 150, 40);
        return canvas.toDataURL("image/png");
      }

      selectTextBtn.onclick = () => {
        const sig = generateTextSignature();
        if (!sig) return;
        resetOtherSigns("name");
        nameSig = sig;
        lastSigType = "name";
        msg.textContent = "‚úÖ Text signature selected (pad & image cleared)";
      };

      document.getElementById("nameDrag").ondragstart = e => {
        const sig = generateTextSignature();
        if (!sig) return e.preventDefault();
        resetOtherSigns("name");
        nameSig = sig;
        lastSigType = "name";
        msg.textContent = "‚úçÔ∏è Text signature ready (pad & image cleared)";
        e.dataTransfer.setData("sigType", "name");
      };

      // ================== Image Signature ==================
      document.getElementById("sigImgInput").onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        resetOtherSigns("img");
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          imgSig = canvas.toDataURL("image/png");
          lastSigType = "img";
          msg.textContent = "üñºÔ∏è Image signature ready (text & pad cleared)";
        };
        img.src = URL.createObjectURL(file);
      };

      // ================== Load Envelope ==================
      async function loadEnvelope() {
        const resp = await fetch(`${BASE}/api/envelopes/by-token/${token}`);
        if (!resp.ok) { msg.textContent = "Envelope not found"; return; }
        const data = await resp.json();
        document.getElementById("envelopeInfo").innerHTML = `<strong>${data.recipientName}</strong>`;
        for (const f of data.files) {
          const fileUrl = f.url.startsWith("http") ? f.url : `${BASE}${f.url}`;
          if (f.mimetype === "text/html" || fileUrl.endsWith(".html")) await renderHtmlUrl(fileUrl);
        }
      }

      async function renderHtmlUrl(url) {
        const iframe = document.createElement("iframe");
        iframe.src = url;
        iframe.className = "docFrame";
        iframe.onload = () => setupIframeDragDrop(iframe);
        stage.appendChild(iframe);
      }

      // ================== Drag & Drop inside iframe ==================
      function setupIframeDragDrop(iframe) {
        const doc = iframe.contentDocument;

        doc.addEventListener("dragover", e => e.preventDefault());

        doc.addEventListener("drop", e => {
          e.preventDefault();
          const sigType = e.dataTransfer.getData("sigType");
          let sigSrc = null;
          if (sigType === "pad") sigSrc = padSig;
          else if (sigType === "name") sigSrc = nameSig;
          else if (sigType === "img") sigSrc = imgSig;
          if (!sigSrc) return alert("Draw or upload a signature first");

          const container = e.target.closest(".signature-line") || doc.body;
          const rect = container.getBoundingClientRect();
          const x = e.clientX - rect.left + container.scrollLeft;
          const y = e.clientY - rect.top + container.scrollTop;

          createSignatureElement(doc, sigSrc, x, y, container, true);
        });

      }

      // ================== Signature Placement (restored parent support) ==================
      function createSignatureElement(doc, src, x, y, parentEl = null, draggableInside = false) {
        const el = doc.createElement("div");
        el.className = "placed-signature";
        Object.assign(el.style, {
          position: "absolute",
          left: (parentEl ? Math.max(0, x) : x) + "px",
          top: (parentEl ? Math.max(0, y) : y) + "px",
          width: "150px",
          height: "70px",
          backgroundImage: `url(${src})`,
          backgroundSize: "contain",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center",
          border: "2px dashed #0af",
          cursor: "move",
          userSelect: "none",
        });

        const closeBtn = doc.createElement("div");
        closeBtn.textContent = "√ó";
        Object.assign(closeBtn.style, {
          position: "absolute",
          top: "-10px",
          right: "-10px",
          width: "20px",
          height: "20px",
          background: "#f33",
          color: "#fff",
          textAlign: "center",
          lineHeight: "20px",
          borderRadius: "50%",
          cursor: "pointer",
        });
        closeBtn.onclick = () => el.remove();
        el.appendChild(closeBtn);

        const handle = doc.createElement("div");
        Object.assign(handle.style, {
          position: "absolute",
          right: "-6px",
          bottom: "-6px",
          width: "12px",
          height: "12px",
          background: "#0af",
          cursor: "se-resize",
        });
        el.appendChild(handle);

        // ---- Dragging ----
        let dragging = false, dx = 0, dy = 0;
        el.addEventListener("mousedown", e => {
          if (e.target === handle || e.target === closeBtn) return;
          dragging = true;
          const rect = el.getBoundingClientRect();
          dx = e.clientX - rect.left;
          dy = e.clientY - rect.top;
          e.preventDefault();
        });


        doc.addEventListener("mousemove", e => {
          if (!dragging) return;
          if (parentEl && draggableInside) {
            const parentRect = parentEl.getBoundingClientRect();
            const newLeft = e.clientX - parentRect.left - dx + parentEl.scrollLeft;
            const newTop = e.clientY - parentRect.top - dy + parentEl.scrollTop;
            const clampedLeft = Math.max(0, Math.min(newLeft, parentEl.clientWidth - el.offsetWidth));
            const clampedTop = Math.max(0, Math.min(newTop, parentEl.clientHeight - el.offsetHeight));
            el.style.left = clampedLeft + "px";
            el.style.top = clampedTop + "px";
          } else {
            const bodyRect = doc.body.getBoundingClientRect();
            const newLeft = e.clientX + doc.documentElement.scrollLeft - bodyRect.left - dx;
            const newTop = e.clientY + doc.documentElement.scrollTop - bodyRect.top - dy;
            el.style.left = newLeft + "px";
            el.style.top = newTop + "px";
          }
        });
        doc.addEventListener("mouseup", () => dragging = false);

        // ---- Resizing ----
        let resizing = false, sx = 0, sy = 0, sw = 0, sh = 0;
        handle.addEventListener("mousedown", e => {
          e.stopPropagation();
          resizing = true;
          sx = e.clientX; sy = e.clientY;
          sw = el.offsetWidth; sh = el.offsetHeight;
        });
        doc.addEventListener("mousemove", e => {
          if (!resizing) return;
          let newW = sw + (e.clientX - sx);
          let newH = sh + (e.clientY - sy);
          if (parentEl && draggableInside) {
            newW = Math.min(newW, parentEl.clientWidth - el.offsetLeft);
            newH = Math.min(newH, parentEl.clientHeight - el.offsetTop);
          }
          el.style.width = Math.max(30, newW) + "px";
          el.style.height = Math.max(20, newH) + "px";
        });
        doc.addEventListener("mouseup", () => resizing = false);

        if (parentEl) parentEl.appendChild(el);
        else doc.body.appendChild(el);
        return el;
      }

      document.getElementById("sigDrag").ondragstart = e => {
        if (!padSig) return e.preventDefault();
        lastSigType = "pad";
        e.dataTransfer.setData("sigType", "pad");
      };
      document.getElementById("imgDrag").ondragstart = e => {
        if (!imgSig) return e.preventDefault();
        lastSigType = "img";
        e.dataTransfer.setData("sigType", "img");
      };

      // ================== Apply To All Docs (uses parentEl + clamp) ==================
      document.getElementById("applyAllBtn").onclick = () => {
        const iframes = document.querySelectorAll(".docFrame");
        let activeSig = null;

        if (lastSigType === "pad") activeSig = padSig;
        else if (lastSigType === "name") activeSig = nameSig;
        else if (lastSigType === "img") activeSig = imgSig;

        if (!activeSig) return msg.textContent = "No active signature found. Please create one.";

        iframes.forEach(frame => {
          const doc = frame.contentDocument;
          const lines = doc.querySelectorAll(".signature-line");
          lines.forEach(line => {
            line.style.position = "relative";
            line.innerHTML = "";
            // place at (0,0) inside the line and keep movement bounded within the line
            createSignatureElement(doc, activeSig, 0, 0, line, true);
          });
        });
        msg.textContent = `‚úÖ '${lastSigType.toUpperCase()}' signature applied to all signature lines.`;
      };

      // ================== Cancel & Complete ==================
      function removeAllSignatures() {
        const iframes = document.querySelectorAll(".docFrame");
        iframes.forEach(frame => {
          const doc = frame.contentDocument;
          if (!doc) return;
          doc.querySelectorAll(".placed-signature, .auto-sign, .signature-line img").forEach(el => el.remove());
        });
      }

      document.getElementById("cancelBtn").onclick = async () => {
        msg.textContent = "Cancelling...";
        removeAllSignatures();
        try {
          const resp = await fetch(`${BASE}/api/envelopes/${token}/cancel`, { method: "POST" });
          msg.textContent = resp.ok
            ? "‚ùå All signatures removed and envelope cancelled successfully."
            : "‚ö†Ô∏è Signatures removed, but cancel API failed.";
        } catch {
          msg.textContent = "‚ùå Error cancelling envelope.";
        }
      };

      // Strip UI (borders/√ó/handles) -> render -> upload
      document.getElementById("completeBtn").onclick = async () => {
        msg.textContent = "Finalizing signatures...";
        const iframes = document.querySelectorAll(".docFrame");

        iframes.forEach(frame => {
          const doc = frame.contentDocument;
          if (!doc) return;
          const sigs = doc.querySelectorAll(".placed-signature");
          sigs.forEach(el => {
            el.style.border = "none";
            el.querySelectorAll("div").forEach(child => child.remove());
          });
        });

        msg.textContent = "Generating PDF...";
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        let added = 0;

        for (const frame of iframes) {
          const canvas = await html2canvas(frame.contentDocument.body, { scale: 2 });
          const imgData = canvas.toDataURL("image/png");
          const pdfW = pdf.internal.pageSize.getWidth();
          const pdfH = pdf.internal.pageSize.getHeight();
          const ratio = Math.min(pdfW / canvas.width, pdfH / canvas.height);
          const w = canvas.width * ratio;
          const h = canvas.height * ratio;
          const x = (pdfW - w) / 2;
          const y = (pdfH - h) / 2;
          if (added > 0) pdf.addPage();
          pdf.addImage(imgData, "PNG", x, y, w, h);
          added++;
        }

        const blob = pdf.output("blob");
        const fd = new FormData();
        fd.append("file", blob, "signed-envelope.pdf");
        msg.textContent = "Uploading signed document...";
        const resp = await fetch(`${BASE}/api/envelopes/${token}/complete`, { method: "POST", body: fd });
        msg.textContent = resp.ok ? "‚úÖ Signed PDF uploaded successfully!" : "‚ùå Upload failed.";
      };

      loadEnvelope();
    })();
  </script>

</body>

</html>